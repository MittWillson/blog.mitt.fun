<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mitt&#39;s Fun space!</title>
  
  
  <link href="https://blog.mitt.fun/atom.xml" rel="self"/>
  
  <link href="https://blog.mitt.fun/"/>
  <updated>2021-02-25T05:07:29.000Z</updated>
  <id>https://blog.mitt.fun/</id>
  
  <author>
    <name>Mitt Willson</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于《Kubernetes 混合云用Kilo解决NAT节点通讯的问题》的那件事</title>
    <link href="https://blog.mitt.fun/service/kubernetes/2021/kubernetes/k8s-%E6%B7%B7%E5%90%88%E4%BA%91%E7%BB%84%E7%BD%91/"/>
    <id>https://blog.mitt.fun/service/kubernetes/2021/kubernetes/k8s-%E6%B7%B7%E5%90%88%E4%BA%91%E7%BB%84%E7%BD%91/</id>
    <published>2021-02-25T05:07:29.000Z</published>
    <updated>2021-02-25T05:07:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pre-post"><a href="#pre-post" class="headerlink" title="pre-post()"></a>pre-post()</h2><p>最近有在学习K8S相关，同时也将自己的所有服务全部都迁移到了K8S集群上，感受到K8S强大的同时也能明显感受到对于我这种一般用户环境的部署不是很友好，例如建议的高可用集群至少要有 <code>三台</code> Master, <code>三台</code> Worker, 对我这种 <del>穷逼</del> 普通玩家来说是很高昂的，但经过几次实践把生产环境搞炸几次后觉得这是有必要的(哭)，但我的想法是用K8S作为我主要部署方式，所以还是非常高昂的，像我这种为了能够管理所有节点但是又不会重度使用K8S的，这里推荐 <code>K3S</code> 来代替K8S作为要求不高的生产环境，不过这篇文章还是用完整的K8S来做，但理论上 <code>K3S</code> 是完全通用的。</p><span id="more"></span><h2 id="subject-‘实现目标’"><a href="#subject-‘实现目标’" class="headerlink" title="subject(‘实现目标’)"></a>subject(‘实现目标’)</h2><p>利用 <code>Kilo</code> 将带有公网IP的NAT云服务器组成K8S集群，支持 <code>P2P</code>, <code>DDNS</code> (要求有公网IP且需要端口映射)</p><h2 id="subject-‘Kilo介绍’"><a href="#subject-‘Kilo介绍’" class="headerlink" title="subject(‘Kilo介绍’)"></a>subject(‘Kilo介绍’)</h2><p><a href="https://github.com/squat/kilo">Kilo</a> 是一个通过 <code>Wireguard</code> 用于建立混合云网络的工具</p><h2 id="subject-‘现有问题’"><a href="#subject-‘现有问题’" class="headerlink" title="subject(‘现有问题’)"></a>subject(‘现有问题’)</h2><p>我的服务器构成是这样的(以下IP皆为虚拟): </p><table><thead><tr><th align="left">Name</th><th align="left">ifc-IP</th><th align="left">Location</th><th align="left">Role</th><th align="left">Nat</th></tr></thead><tbody><tr><td align="left">k8s-master</td><td align="left">123.123.123.123</td><td align="left">Hetzner</td><td align="left">Master</td><td align="left">NO</td></tr><tr><td align="left">cn-sh01-node</td><td align="left">10.0.0.4</td><td align="left">QCloud</td><td align="left">Worker</td><td align="left">YES</td></tr><tr><td align="left">cn-hz01-node</td><td align="left">192.168.1.120</td><td align="left">Home</td><td align="left">Worker</td><td align="left">YES</td></tr></tbody></table><p>可以看到我的三台服务器都不是同一个网段甚至都不是同一个服务商的。<br>所以会有几个问题</p><ul><li>kube-proxy 无法正常工作转发流量</li><li>metrics 采集无法工作</li><li>logs/shell 无法工作</li></ul><h2 id="subject-‘解决问题’"><a href="#subject-‘解决问题’" class="headerlink" title="subject(‘解决问题’)"></a>subject(‘解决问题’)</h2><p>之前是用 <code>Weave</code> 来作为CNI的，然后为了解决 <code>kube-proxy</code> 的一些问题换成了 <code>Flannel</code>, 网上查找一些资料和issues以后发现如果要解决这个问题，就得先将所有节点连起来，连起来的方法就是VPN，然后让通讯流量走VPN接口即可解决，但是按常规理解VPN流量是需要中心服务器转发流量的，那就会导致所有流量转发到同一台服务器，压力和延迟也会非常大不符合需求，然后我去搜了P2P VPN发现 <code>Wireguard</code> 是支持Peer2Peer的，顺势在某个issue里看到有人提到用 <code>Kilo</code> 进行自动组网，并且 <code>Kilo</code> 是支持在 <code>Flannel</code> 之上运行的</p><h3 id="端口通讯检查"><a href="#端口通讯检查" class="headerlink" title="端口通讯检查"></a>端口通讯检查</h3><p>我是采用 Flannel+Calico+Kilo 的方式设置网络的，所以需要以下端口放通</p><table><thead><tr><th align="left">Port Range</th><th align="left">Protocol</th><th align="left">Remark</th></tr></thead><tbody><tr><td align="left">8285</td><td align="left">&nbsp;UDP&nbsp;</td><td align="left">Flannel</td></tr><tr><td align="left">8472</td><td align="left">&nbsp;UDP&nbsp;</td><td align="left">Flannel</td></tr><tr><td align="left">51820</td><td align="left">&nbsp;UDP&nbsp;</td><td align="left">Wireguard 默认端口</td></tr><tr><td align="left">10250</td><td align="left">&nbsp;TCP&nbsp;</td><td align="left">Kubelet API</td></tr><tr><td align="left">30000-32767</td><td align="left">&nbsp;TCP+UDP&nbsp;</td><td align="left">NodePort 服务端口</td></tr></tbody></table><h3 id="安装-Kilo"><a href="#安装-Kilo" class="headerlink" title="安装 Kilo"></a>安装 Kilo</h3><p>Kubeadm</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/squat/</span>kilo<span class="regexp">/master/m</span>anifests/kilo-kubeadm-flannel.yaml</span><br></pre></td></tr></table></figure><blockquote><p>如果要卸载，直接 kubectl delete 就好了</p></blockquote><h3 id="配置外部连接IP"><a href="#配置外部连接IP" class="headerlink" title="配置外部连接IP"></a>配置外部连接IP</h3><p>由于目前尚未支持 <code>NAT to NAT(理论可以实现)</code>，所以每个Node都必须具备外部(公网)访问条件，但是你会发现一件事，每个Node都只会拿到网卡的IP，它没办法发现你的外部IP</p><p>所以就像 <code>Flannel</code> 通过 <code>flannel.alpha.coreos.com/public-ip-overwrite</code> 来覆写外部通讯IP一样 <code>Kilo</code> 同样也提供了 <code>kilo.squat.ai/force-endpoint</code> 来指定外部通讯连接点，格式是 <code>&quot;IP:PORT&quot;</code> 或者 <code>&quot;[DOMAIN]:PORT&quot;</code>，是的，它支持域名，所以就可以实现我们 <code>HOME</code> worker的DDNS需求，只要防火墙放通端口或者路由器转发端口就可以自由通讯了</p><p>编辑 <code>cn-hz01-node</code> 节点，在 <code>metadata.annotations</code> 里加入 <code>kilo.squat.ai/force-endpoint: &#39;[home.mydomain.com]:51820&#39;</code>，然后过一会通过 <code>kubectl desc node cn-hz01-node</code> 就可以看到它自动解析了域名并且添加了一个新的 <code>kilo.squat.ai/endpoint</code> annotation，值为你域名指向的IP</p><p>同样此方法去更改 <code>cn-sh01-node</code> 的 annotations，过一会就可以看到 metrics 信息已经正常显示了(前提是你已经部署了metrics采集)</p><blockquote><p>建议采用 <code>Flannel</code> 的 <code>vxlan</code> 作为后端，不采用 <code>IPSec</code> 等加密后端避免不必要的二次开销</p></blockquote><h3 id="关于P2P实现"><a href="#关于P2P实现" class="headerlink" title="关于P2P实现"></a>关于P2P实现</h3><blockquote><p>目前 <code>Kilo</code> 的P2P实现还在讨论并且已经在计划适配，具体可以在这里看到 <a href="https://github.com/squat/kilo/issues/109">https://github.com/squat/kilo/issues/109</a></p></blockquote><h2 id="subject-‘不通过VPN外部直连的可能性’"><a href="#subject-‘不通过VPN外部直连的可能性’" class="headerlink" title="subject(‘不通过VPN外部直连的可能性’)"></a>subject(‘不通过VPN外部直连的可能性’)</h2><p>说个题外话，假如全部NODE都是有公网IP但是会有一层NAT的能不能正常通讯呢，这个读过一点Kubernetes的代码，这个是有可能的，就是更改Node的 <code>status.addresses</code> 添加一个 <code>Type</code> 为 <code>ExternalIP</code> 的IP地址，但是这里有个问题就是，你没办法直接编辑或者patch一个node的status值，那么这个addresses是怎么来的呢？</p><p>addresses 实际上是通过 <code>cloud-provider</code> 设置的，他读取你的网卡并将其IP设置为 <code>InternalIP</code> 的address, 如果你是GCE, Azure等，他们会去跟平台通讯获取你机器的外网绑定网卡信息，并且设置为 <code>ExternalIP</code>，而 <code>metrics-server</code> 的默认启动参数 <code>--kubelet-preferred-address-types=ExternalIP,InternalIP,Hostname</code> 定义了它会尝试去和外部IP、内部IP、主机名进行通讯，所以如果你是通过云服务商的k8s托管，那么它就会自动设置外部IP，但是手工设置是行不通的，所以如果自己写一个 “Fake” cloud-provider 的话也许也行得通，但其实价值就很低了，不如直接VPN组网来的实在。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pre-post&quot;&gt;&lt;a href=&quot;#pre-post&quot; class=&quot;headerlink&quot; title=&quot;pre-post()&quot;&gt;&lt;/a&gt;pre-post()&lt;/h2&gt;&lt;p&gt;最近有在学习K8S相关，同时也将自己的所有服务全部都迁移到了K8S集群上，感受到K8S强大的同时也能明显感受到对于我这种一般用户环境的部署不是很友好，例如建议的高可用集群至少要有 &lt;code&gt;三台&lt;/code&gt; Master, &lt;code&gt;三台&lt;/code&gt; Worker, 对我这种 &lt;del&gt;穷逼&lt;/del&gt; 普通玩家来说是很高昂的，但经过几次实践把生产环境搞炸几次后觉得这是有必要的(哭)，但我的想法是用K8S作为我主要部署方式，所以还是非常高昂的，像我这种为了能够管理所有节点但是又不会重度使用K8S的，这里推荐 &lt;code&gt;K3S&lt;/code&gt; 来代替K8S作为要求不高的生产环境，不过这篇文章还是用完整的K8S来做，但理论上 &lt;code&gt;K3S&lt;/code&gt; 是完全通用的。&lt;/p&gt;</summary>
    
    
    
    <category term="service" scheme="https://blog.mitt.fun/categories/service/"/>
    
    <category term="kubernetes" scheme="https://blog.mitt.fun/categories/service/kubernetes/"/>
    
    
    <category term="Wireguard" scheme="https://blog.mitt.fun/tags/Wireguard/"/>
    
    <category term="Kilo" scheme="https://blog.mitt.fun/tags/Kilo/"/>
    
    <category term="Peer2Peer" scheme="https://blog.mitt.fun/tags/Peer2Peer/"/>
    
    <category term="Kubernetes" scheme="https://blog.mitt.fun/tags/Kubernetes/"/>
    
    <category term="K8S" scheme="https://blog.mitt.fun/tags/K8S/"/>
    
    <category term="K3S" scheme="https://blog.mitt.fun/tags/K3S/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 给每个容器配置公网IP</title>
    <link href="https://blog.mitt.fun/service/2018/docker/Docker-%E7%BB%99%E6%AF%8F%E4%B8%AA%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E5%85%AC%E7%BD%91IP/"/>
    <id>https://blog.mitt.fun/service/2018/docker/Docker-%E7%BB%99%E6%AF%8F%E4%B8%AA%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E5%85%AC%E7%BD%91IP/</id>
    <published>2018-05-01T12:28:08.000Z</published>
    <updated>2021-02-25T11:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pre-post"><a href="#pre-post" class="headerlink" title="pre-post()"></a>pre-post()</h2><p>为了方便部署流量转发服务，采用了Docker来干这个事，一般情况下一台节点只有一个IP，使用端口映射或者用参数 <code>--network host</code> 直接使用主机的网络来监听和转发是没有问题的，但是有一些节点会存在多个或一个段的外部IP，这时候虽然 <code>IN</code> 方向没有问题，但是 <code>OUT</code> 方向只会采用主机设置的默认路由来访问，就导致了转发的流量都使用同一个IP转发出去了，这是不对的，所以接下来就研究如何才能自定义出口流量，这篇文章则采用给容器配置外部IP的方式实现。</p><blockquote><p>此方法适合非NAT主机</p></blockquote><span id="more"></span><h2 id="subject-‘实现目标’"><a href="#subject-‘实现目标’" class="headerlink" title="subject(‘实现目标’)"></a>subject(‘实现目标’)</h2><p>给每个 Docker 容器都配置不同的公网IP出口</p><h2 id="solution-‘附加网络到容器’"><a href="#solution-‘附加网络到容器’" class="headerlink" title="solution(‘附加网络到容器’)"></a>solution(‘附加网络到容器’)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 eth1 接口删除IP</span></span><br><span class="line">$ sudo ip addr del 192.168.33.10/24 dev eth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个桥接名称为 “docker1” 的 shared_nw 网络</span></span><br><span class="line">$ sudo docker network create --driver bridge --subnet=192.168.33.0/24 --gateway=192.168.33.10 --opt <span class="string">&quot;com.docker.network.bridge.name&quot;</span>=<span class="string">&quot;docker1&quot;</span> shared_nw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 “docker1” 到 eth1</span></span><br><span class="line">$ sudo brctl addif docker1 eth1</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>192.168.33.0/24</code> 是子网段, <code>192.168.33.10</code> 是IP地址</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 curl 容器来验证IP结果</span></span><br><span class="line">$ docker run -it curlimages/curl --net shared_nw --ip 192.168.33.11 ip.sb</span><br><span class="line"><span class="comment"># 输出结果: 192.168.33.11</span></span><br></pre></td></tr></table></figure><p>这样这个容器本身的IP就变成了外部IP</p><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>采用这种方法会把主机的IP剥离，如果你没有其他接入网卡的话会导致断网无法外部进入，只能通过 <code>Console</code> 来调整</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ul><li><a href="https://forums.docker.com/t/public-accessible-ip-in-container-like-bridge-network-in-virtualbox/3668/6">https://forums.docker.com/t/public-accessible-ip-in-container-like-bridge-network-in-virtualbox/3668/6</a></li><li><a href="https://qiita.com/kjtanaka/items/f16757c1f0cc86ff225b">https://qiita.com/kjtanaka/items/f16757c1f0cc86ff225b</a></li></ul><h2 id="solution-‘桥接网络IP’"><a href="#solution-‘桥接网络IP’" class="headerlink" title="solution(‘桥接网络IP’)"></a>solution(‘桥接网络IP’)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 &quot;pnet01&quot; 的 macvlan 网络</span></span><br><span class="line">$ docker network create -d macvlan --subnet 23.89.4.0/24 --gateway 23.89.4.1 -o parent=ens3 --aux-address=<span class="string">&quot;master=23.89.4.205&quot;</span> pnet01</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>23.89.4.0/24</code> 是子网段, <code>23.89.4.1</code> 是网关地址, <code>ens3</code> 是网卡接口名称, <code>23.89.4.205</code> 是外部IP</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 curl 容器来验证IP结果</span></span><br><span class="line">$ docker run -it curlimages/curl --net pnet01 --ip 23.89.4.207 ip.sb</span><br><span class="line"><span class="comment"># 输出结果: 23.89.4.207</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>23.89.4.207</code> 是要分配给容器的同网段的IP</p></blockquote><h3 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h3><p>主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ifconfig</span></span><br><span class="line">ens3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 23.89.4.205  netmask 255.255.255.0  broadcast 23.89.4.255</span><br><span class="line">        inet6 fe80::216:3cff:fe7e:fbeb  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3c:7e:fb:eb  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 96281  bytes 7457992 (7.1 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5325  bytes 1603561 (1.5 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># route</span></span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         1.4-89-23.rdns. 0.0.0.0         UG    0      0        0 ens3</span><br><span class="line">localnet        0.0.0.0         255.255.255.0   U     0      0        0 ens3</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br></pre></td></tr></table></figure><p>容器内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:17:59:04:CF</span><br><span class="line">          inet addr:23.89.4.207  Bcast:0.0.0.0  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:27457 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:579 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:1839527 (1.7 MiB)  TX bytes:81473 (79.5 KiB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># route</span></span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         1.4-89-23.rdns. 0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">23.89.4.0       *               255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure><h3 id="弊端-1"><a href="#弊端-1" class="headerlink" title="弊端"></a>弊端</h3><p>仅适用于拥有一个段的IP的服务器，采用这种方式的主机会保留一个IP用于通讯和桥接，然后分配同网段的其他IP给容器，如果有不同网段和网关的IP，就需要同样创建第二个网络</p><h3 id="参考来源-1"><a href="#参考来源-1" class="headerlink" title="参考来源"></a>参考来源</h3><ul><li><a href="https://docs.docker.com/network/network-tutorial-macvlan/#bridge-example">https://docs.docker.com/network/network-tutorial-macvlan/#bridge-example</a></li><li><a href="https://www.aquasec.com/wiki/display/containers/Docker+Networking+101">https://www.aquasec.com/wiki/display/containers/Docker+Networking+101</a></li></ul><h2 id="subject-‘End’"><a href="#subject-‘End’" class="headerlink" title="subject(‘End’)"></a>subject(‘End’)</h2><p>这篇文章内容是 <code>2018</code> 年写的，一直摸鱼到 <code>2021</code> 年才补上，对现在的我来说对容器以及网络方面有了新的理解，所以这篇文章内容其实也算是有点 <code>过时</code> 了，还有一个方法是采用 <code>iptables</code> NAT进行实现，但是人工维护显然有些繁琐，虽然我没有再这个方向继续研究了，但是希望能给有需要的人一个参考。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pre-post&quot;&gt;&lt;a href=&quot;#pre-post&quot; class=&quot;headerlink&quot; title=&quot;pre-post()&quot;&gt;&lt;/a&gt;pre-post()&lt;/h2&gt;&lt;p&gt;为了方便部署流量转发服务，采用了Docker来干这个事，一般情况下一台节点只有一个IP，使用端口映射或者用参数 &lt;code&gt;--network host&lt;/code&gt; 直接使用主机的网络来监听和转发是没有问题的，但是有一些节点会存在多个或一个段的外部IP，这时候虽然 &lt;code&gt;IN&lt;/code&gt; 方向没有问题，但是 &lt;code&gt;OUT&lt;/code&gt; 方向只会采用主机设置的默认路由来访问，就导致了转发的流量都使用同一个IP转发出去了，这是不对的，所以接下来就研究如何才能自定义出口流量，这篇文章则采用给容器配置外部IP的方式实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此方法适合非NAT主机&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="service" scheme="https://blog.mitt.fun/categories/service/"/>
    
    
    <category term="Docker" scheme="https://blog.mitt.fun/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.mitt.fun/nihility/2018/hello-world/"/>
    <id>https://blog.mitt.fun/nihility/2018/hello-world/</id>
    <published>2018-01-28T17:30:37.000Z</published>
    <updated>2021-02-25T03:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hello Everyone, I’m Mitt, and I wish you all Have fun every day!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello Everyone, I’m Mitt, and I wish you all Have fun every day!&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Milestone" scheme="https://blog.mitt.fun/tags/Milestone/"/>
    
  </entry>
  
</feed>
